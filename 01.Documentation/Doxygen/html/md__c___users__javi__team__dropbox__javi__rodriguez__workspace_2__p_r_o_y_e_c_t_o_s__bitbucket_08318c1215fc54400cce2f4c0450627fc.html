<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Battery doc: SoftI2CMaster</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Battery doc
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md__c___users__javi__team__dropbox__javi__rodriguez__workspace_2__p_r_o_y_e_c_t_o_s__bitbucket_08318c1215fc54400cce2f4c0450627fc.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">SoftI2CMaster </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md129"></a>
Why another I2C library?</h1>
<p >The standard I2C library for the Arduino is the <a href="http://arduino.cc/en/Reference/Wire">Wire Library</a>. While this library is sufficient most of the time when you want to communicate with devices, there are situations when it is not applicable:</p><ul>
<li>the I2C pins SDA/SCL are in use already for other purposes,</li>
<li>the code shall run on an ATtiny processor with 1 MHz on arbitrary pins,</li>
<li>you are short on memory (flash and RAM), or</li>
<li>you do not want to use the implicitly enabled pull-up resistors because your devices are run with 3 volts.</li>
</ul>
<p >I adapted <a href="http://homepage.hispeed.ch/peterfleury/avr-software.html">Peter Fleury's I2C software library</a> that is written in AVR assembler, extremely light weight (just under 500 byte in flash) and very fast. Even on an ATtiny running with 1MHz, one can still operate the bus with 33 kHz, which implies that you can drive slave devices that use the SMBus protocol (which timeout if the the bus frequency is below 10 kHz).</p>
<p >If you want a solution running on an ARM MCU (Due, Zero, Teensy 3.x), you want to use pins on port H or above on an ATmega256, or you want to use many different I2C buses, this library is not the right solution for you. In these cases, another bit-banging I2C library written in pure C++ could perhaps help you: <a href="https://github.com/felias-fogg/SlowSoftI2CMaster">SlowSoftI2CMaster</a>.</p>
<h1><a class="anchor" id="autotoc_md130"></a>
Features</h1>
<p >This library has the following features:</p><ul>
<li>supports only master mode</li>
<li>compatible with all 8-bit AVR MCUs</li>
<li>no bus arbitration (i.e., only one master allowed on bus)</li>
<li>clock stretching (by slaves) supported</li>
<li>timeout on clock stretching</li>
<li>timeout on ACK polling for busy devices (new!)</li>
<li>internal MCU pullup resistors can be used (new!)</li>
<li>can make use of almost any pin (except for pins on port H and above on large ATmegas)</li>
<li>very lightweight (roughly 500 bytes of flash and 0 byte of RAM, except for call stack)</li>
<li>it is not interrupt-driven</li>
<li>very fast (standard and fast mode on ATmega328, 33 kHz on ATtiny with 1 MHz CPU clock)</li>
<li>Optional <code>Wire</code> library compatible interface</li>
<li>GPL license</li>
</ul>
<h1><a class="anchor" id="autotoc_md131"></a>
Installation</h1>
<p >Just download the <a href="https://github.com/felias-fogg/SoftI2CMaster">Zip-File from github</a>, uncompress, rename the directory to <code>SoftI2CMaster</code> and move it into the <code>libraries</code> folder. In case you have not installed a library before, consult the the respective <a href="http://arduino.cc/en/Guide/Libraries">help page</a>.</p>
<h1><a class="anchor" id="autotoc_md132"></a>
Importing the library</h1>
<p >In order to use the library, you have to import it using the include statement: </p><pre class="fragment">#include &lt;SoftI2CMaster.h&gt;
</pre><p> In the program text <em>before</em> the include statement, some compile-time parameters have to be specified, such as which pins are used for the data (SDA) and clock (SCL) lines. These pins have to be specified in a way so that <a href="http://www.arduino.cc/en/Reference/PortManipulation">port manipulation commands</a> can be used. Instead of specifying the number of the digital pin (0-19), the <em>port</em> (PORTB, PORTC, PORTD) and the <em>port pin</em> has to be specified. The mapping is explained <a href="http://www.arduino.cc/en/Reference/PortManipulation">here</a>. For example, if you want to use <em>digital pin 2</em> for <em>SCL</em> and <em>digital pin 14</em> (= analog pin 0) for <em>SDA</em>, you have to specify <em>port pin 2 of PORTD</em> for SCL and <em>port pin 0 of PORTC</em> for SDA: </p><pre class="fragment">#define SCL_PIN 2
#define SCL_PORT PORTD
#define SDA_PIN 0
#define SDA_PORT PORTC
#include &lt;SoftI2CMaster.h&gt;
</pre><h1><a class="anchor" id="autotoc_md133"></a>
Configuration</h1>
<p >There are a few other constants that you can define in order to control the behavior of the library. You have to specify them before the <code>include</code> statement so that they can take effect. Note that this different from the usual form of libraries! This library is always compiled with your sketch and therefore the <code>defines</code> need to be specfied before the inclusion of the library! </p><pre class="fragment">#define I2C_HARDWARE 1
</pre><p> Although this is basically a bit-banging library, there is the possibility to use the hardware support for I2C, if you happen to run this library on an MCU such as the ATmega328 that implements this. If this constant is set to 1, then the hardware registers are used (and you have to use the standard SDA and SCL pins). </p><pre class="fragment">#define I2C_PULLUP 1
</pre><p> With this definition you enable the internal pullup resistores of the MCU. Note that the internal pullups have around 50k&amp;#x2126;, which may be too high. This slows down the bus speed somewhat. Furthermore, when switching from <code>HIGH</code> to <code>LOW</code> (or the other way around), the bus lines will temporarily in a high impedance state. With low I2C frequencies, things will probably work. However, be careful when using this option and better check with a scope that things work out. </p><pre class="fragment">#define I2C_TIMEOUT ...
</pre><p> Since slave devices can stretch the low period of the clock indefinitely, they can lock up the MCU. In order to avoid this, one can define <code>I2C_TIMEOUT</code>. Specify the number of milliseconds after which the I2C functions will time out. Possible values are 0 (no time out) to 10000 (i.e., 10 seconds). Enabling this option slows done the bus speed somewhat. </p><pre class="fragment">#define I2C_MAXWAIT ...
</pre><p> When waiting for a busy device, one may use the function <code>i2c_start_wait(addr)</code> (see below), which sends start commands until the device responds with an <code>ACK</code>. If the value of this constant is different from 0, then it specifies the maximal number of start commands to be sent. Default value is 1000. </p><pre class="fragment">#define I2C_NOINTERRUPT 1
</pre><p> With this definition you disable interrupts between issuing a start condition and terminating the transfer with a stop condition. Usually, this is not necessary. However, if you have an SMbus device that can timeout, one may want to use this feature. Note however, that in this case interrupts become unconditionally disabled when calling <code>i2c_start(...)</code> und unconditionally enabled after calling <code><a class="el" href="mockup_8cpp.html#a5149736c791184da23d658764e9da861">i2c_stop()</a></code>. </p><pre class="fragment">#define I2C_CPUFREQ ...
</pre><p> If you are changing the CPU frequency dynamically using the clock prescale register CLKPR and intend to call the I2C functions with a frequency different from F_CPU, then define this constant with the correct frequency. For instance, if you used a prescale factor of 8, then the following definition would be adequate: <code>#define I2C_CPUFREQ (F_CPU/8)</code> </p><pre class="fragment">#define I2C_FASTMODE 1
</pre><p> The <em>standard I2C bus frequency</em> is 100kHz. Often, however, devices permit for faster transfers up to 400kHz. If you want to allow for the higher frequency, then the above definition should be used. </p><pre class="fragment">#define I2C_SLOWMODE 1
</pre><p> In case you want to slow down the clock frequency to less than 25kHz, you can use this definition (in this case, do not define <code>I2C_FASTMODE</code>!). This can help to make the communication more reliable.</p>
<p >I have measured the maximal bus frequency under different processor speeds. The results are displayed in the following table. The left value is with <code>I2C_TIMEOUT</code> and <code>I2C_PULLUP</code> disabled. The right value is the bus frequency with both options enabled. Note also that there is a high clock jitter (roughly 10-15%) because the clock is implemented by delay loops. This is not a problem for the I2C bus, though. However, the throughput might be lower than one would expect from the numbers in the table.</p>
<table class="doxtable">
<tr>
<th></th><th colspan="2" align="center">1 MHz </th><th colspan="2" align="center">2 MHz </th><th colspan="2" align="center">4 MHz </th><th colspan="2" align="center">8 MHz </th><th colspan="2" align="center"><p class="starttd">16 MHz </p>
<p class="endtd"></p>
</th></tr>
<tr>
<td align="left">Slow mode (kHz) </td><td align="right">23 </td><td align="right">21 </td><td align="right">24 </td><td align="right">22 </td><td align="right">24 </td><td align="right">23</td><td align="right">24 </td><td align="right">23</td><td align="right">24 </td><td align="right"><p class="starttd">23</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td align="left">Standard mode (kHz) </td><td align="right">45 </td><td align="right">33</td><td align="right">90 </td><td align="right">72 </td><td align="right">95 </td><td align="right">83</td><td align="right">95 </td><td align="right">89</td><td align="right">90 </td><td align="right"><p class="starttd">88</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td align="left">Fast mode (kHz) </td><td align="right">45 </td><td align="right">33</td><td align="right">90 </td><td align="right">72</td><td align="right">180 </td><td align="right">140</td><td align="right">370 </td><td align="right">290</td><td align="right">370 </td><td align="right">330 </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md134"></a>
Interface</h1>
<p >The following functions are provided by the library: </p><pre class="fragment">i2c_init()
</pre><p> Initialize the I2C system. Must be called once in <code>setup</code>. Will return <code>false</code> if SDA or SCL is on a low level, which means that the bus is locked. Otherwise returns <code>true</code>. </p><pre class="fragment">i2c_start(addr)
</pre><p> Initiates a transfer to the slave device with the 8-bit I2C address *<code>addr</code>*. Note that this library uses the 8-bit addressing scheme different from the 7-bit scheme in the Wire library. In addition the least significant bit of *<code>addr</code>* must be specified as <code>I2C_WRITE</code> (=0) or <code>I2C_READ</code> (=1). Returns <code>true</code> if the addressed device replies with an <code>ACK</code>. Otherwise <code>false</code> is returned. </p><pre class="fragment">i2c_start_wait(addr)
</pre><p> Similar to the <code>i2c_start</code> function. However, it tries repeatedly to start the transfer until the device sends an acknowledge. It will timeout after <code>I2C_MAXWAIT</code> failed attempts to contact the device (if this value is different from 0). By default, this value is 1000. </p><pre class="fragment">i2c_rep_start(addr)
</pre><p> Sends a repeated start condition, i.e., it starts a new transfer without sending first a stop condition. Same return value as <code><a class="el" href="mockup_8cpp.html#a876a5d83cf8b5fa662b04a81657d8d30">i2c_start()</a></code>. </p><pre class="fragment">i2c_stop()
</pre><p> Sends a stop condition and thereby releases the bus. No return value. </p><pre class="fragment">i2c_write(byte)
</pre><p> Sends a byte to the previously addressed device. Returns <code>true</code> if the device replies with an ACK, otherwise <code>false</code>. </p><pre class="fragment">i2c_read(last)
</pre><p> Requests to receive a byte from the slave device. If <code>last</code> is <code>true</code>, then a <code>NAK</code> is sent after receiving the byte finishing the read transfer sequence. The function returns the received byte.</p>
<h1><a class="anchor" id="autotoc_md135"></a>
Example</h1>
<p >As a small example, let us consider reading one register from an I2C device, with an address space &lt; 256 (i.e. one byte for addressing) </p><pre class="fragment">// Simple sketch to read out one register of an I2C device
#define SDA_PORT PORTC
#define SDA_PIN 4 // = A4
#define SCL_PORT PORTC
#define SCL_PIN 5 // = A5
#include &lt;SoftI2CMaster.h&gt;

#define I2C_7BITADDR 0x68 // DS1307
#define MEMLOC 0x0A 

void setup(void) {
    Serial.begin(57600);
    if (!i2c_init()) // Initialize everything and check for bus lockup
        Serial.println("I2C init failed");
}

void loop(void){
    if (!i2c_start((I2C_7BITADDR&lt;&lt;1)|I2C_WRITE)) { // start transfer
        Serial.println("I2C device busy");
        return;
    }
    i2c_write(MEMLOC); // send memory address
    i2c_rep_start((I2C_7BITADDR&lt;&lt;1)|I2C_READ); // restart for reading
    byte val = i2c_read(true); // read one byte and send NAK to terminate
    i2c_stop(); // send stop condition
    Serial.println(val);
    delay(1000);
}
</pre> <h1><a class="anchor" id="autotoc_md136"></a>
I2CShell</h1>
<p >In the example directory, you find a much more elaborate example: <code>I2CShell</code>. This sketch can be used to interact with I2C devices similar in the way you can use the Bus Pirate. For example, you can type: </p><pre class="fragment">[ 0xAE 0 0 [ 0xAF r:5 ]
</pre><p> This will address the I2C device under the (8-bit) address in write mode, set the reading register to 0, then opens the same device again in read mode and read 5 registers. A complete documentation of this program can be found in the <a href="https://github.com/felias-fogg/SoftI2CMaster/tree/master/examples/I2CShell">I2CShell example folder</a>.</p>
<h1><a class="anchor" id="autotoc_md137"></a>
Alternative Interface</h1>
<p >Meanwhile, I have written a wrapper around SoftI2CMaster that emulates the <a href="http://arduino.cc/en/Reference/Wire">Wire library</a> (master mode only). It is another C++-header file called <code><a class="el" href="_soft_wire_8h.html">SoftWire.h</a></code>, which you need to include instead of <code><a class="el" href="_soft_i2_c_master_8h.html">SoftI2CMaster.h</a></code>. The ports and pins have to be specified as described above. After the include statement you need to create a <code><a class="el" href="class_soft_wire.html">SoftWire</a></code> instance: </p><pre class="fragment">#define SDA_PORT ...
...
#include &lt;SoftWire.h&gt;
SoftWire Wire = SoftWire();
...
setup() {
    Wire.begin()
...
}
</pre><p> This interface sacrifices some of the advantages of the original library, in particular its small footprint, but comes handy if you need a replacement of the original <em>Wire</em> library. The following section sketches the memory footprint of different I2C libraries.</p>
<p >Instead of the <a class="el" href="class_soft_wire.html">SoftWire</a> wrapper, one can use the alternative wrapper WireEmu. Include <code>SoftI2CMaster</code>in your main sketch. Then <code>WireEmu</code>can be used as a drop-in replacement for the Wire instance (also claiming to be an instance of TwoWire).</p>
<h1><a class="anchor" id="autotoc_md138"></a>
Memory requirements</h1>
<p >In order to measure the memory requirements of the different libraries, I wrote a baseline sketch, which contains all necessary I2C calls for reading and writing an EEPROM device, and compiled it against a library with empty functions. Then all the other libraries were used. For the Wire-like libraries, I had to rewrite the sketch, but it has the same functionality. The memory requirements differ somewhat from ATmega to ATtiny, but the overall picture is similar. The take-home message is: If you are short on memory (flash or RAM), it makes sense to use the SoftI2CMaster library.</p>
<table align="right">
<tr>
<td colspan="10" align="center">ATmega328 </td></tr>
<tr>
<th>Library</th><th align="center">SoftI2C-</th><th align="center">SoftI2C-</th><th align="center">SoftI2C-</th><th align="center">Soft-</th><th align="center">SlowSoft-</th><th align="center">SlowSoft-</th><th align="center">USI-</th><th align="center">Tiny-</th><th align="center">Wire </th></tr>
<tr>
<th></th><th align="center">Master</th><th align="center">Master</th><th align="center">Master</th><th align="center">Wire</th><th align="center">I2CMaster</th><th align="center">Wire</th><th align="center">Wire</th><th align="center">Wire</th><th align="center"></th></tr>
<tr>
<th>Option</th><th align="center"></th><td align="center">Pullup+Timeout</td><td align="center">Hardware</td><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th></tr>
<tr>
<td>Flash</td><td align="right">482</td><td align="right">564</td><td align="right">434</td><td align="right">1066</td><td align="right">974</td><td align="right">1556</td><td align="center">-</td><td align="center">-</td><td align="right">1972 </td></tr>
<tr>
<td>RAM</td><td align="right">0</td><td align="right">0</td><td align="right">0</td><td align="right">66</td><td align="right">4</td><td align="right">70</td><td align="center">-</td><td align="center">-</td><td align="right">210 </td></tr>
</table>
<table align="right">
<tr>
<td colspan="10" align="center">ATtiny85 </td></tr>
<tr>
<th>Library</th><th align="center">SoftI2C-</th><th align="center">SoftI2C-</th><th align="center">SoftI2C-</th><th align="center">Soft-</th><th align="center">SlowSoft-</th><th align="center">SlowSoft-</th><th align="center">USI-</th><th align="center">Tiny-</th><th align="center">Wire </th></tr>
<tr>
<th></th><th align="center">Master</th><th align="center">Master</th><th align="center">Master</th><th align="center">Wire</th><th align="center">I2CMaster</th><th align="center">Wire</th><th align="center">Wire</th><th align="center">Wire</th><th align="center"></th></tr>
<tr>
<th>Option</th><th align="center"></th><td align="center">Pullup+Timeout</td><td align="center">Hardware</td><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th></tr>
<tr>
<td>Flash</td><td align="right">428</td><td align="right">510</td><td align="center">-</td><td align="right">1002</td><td align="right">732</td><td align="right">1292</td><td align="right">1108</td><td align="right">1834</td><td align="center">- </td></tr>
<tr>
<td>RAM</td><td align="right">0</td><td align="right">0</td><td align="center">-</td><td align="right">66</td><td align="right">4</td><td align="right">70</td><td align="right">45</td><td align="right">86</td><td align="center">- </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md139"></a>
Shortcomings</h1>
<p >The entire code had to be included in the header file, because the communication ports in the code need to be determined at compile time. This implies that this header file should only be included once per project (usually in the sketch).</p>
<p >Another shortcoming is that one cannot use ports H and above on an ATmega256. The reason is that these ports are not directly addressable.</p>
<p >Finally, as mentioned, the code runs only on AVR MCUs (because it uses assembler). If you want to use a software I2C library on the ARM platform, you could use <a href="https://github.com/felias-fogg/SlowSoftI2CMaster">https://github.com/felias-fogg/SlowSoftI2CMaster</a>, which uses only C++ code. Because of this, it is much slower, but on a Genuino/Arduino Zero, the I2C bus runs with roughly 100kHz. There is also a Wire-like wrapper available for this library: <a href="https://github.com/felias-fogg/SlowSoftWire">https://github.com/felias-fogg/SlowSoftWire</a>. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3 </li>
  </ul>
</div>
</body>
</html>
